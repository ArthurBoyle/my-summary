### 1. js事件循环机制
&emsp;&emsp;事件循环Event Loop，这是目前浏览器和NodeJS处理JavaScript代码的一种机制，而这种机制存在的背后，就有因为JavaScript是一门单线程的语言。

&emsp;&emsp;JavaScript之所谓设计为单线程语言，主要是因为它作为浏览器脚本语言，主要的用途就是与用户互动，操作Dom节点。

#### 调用栈 Call Stack
&emsp;&emsp;在JavaScript运行的时候，主线程会形成一个栈，这个栈主要是解释器用来最终函数执行流的一种机制。调用栈内存放的是代码执行期间的所有执行上下文。
* 每调用一个函数，解释器就会把该函数的执行上下文添加到调用栈并开始执行；
* 正在调用栈中执行的函数，如果还调用了其他函数，那么新函数也会被添加到调用栈，并立即执行；
* 当前函数执行完毕后，解释器会将其执行上下文清除调用栈，继续执行剩余执行上下文中的剩余代码； 
* 但分配的调用栈空间被占满，会引发”堆栈溢出“的报错;

#### 同步任务和异步任务
&emsp;&emsp;同步任务的执行，按照代码顺序和调用顺序，支持进入调用栈中并执行，执行结束后就移除调用栈。

&emsp;&emsp;异步任务的执行，首先它依旧会进入调用栈中，然后发起调用，然后解释器会将其响应回调任务放入一个任务队列，紧接着调用栈会将这个任务移除。当主线程清空后，即所有同步任务结束后，解释器会读取任务队列，并依次将已完成的异步任务加入调用栈中并执行。

#### 宏任务与微任务
&emsp;&emsp;宏任务和微任务都是异步任务。宏任务和微任务的区别在于它们执行的顺序不一样。

#### 事件循环 Event Loop
1. 从宏任务队列中，按照入队顺序，找到第一个执行的宏任务，放入调用栈，开始执行；
2. 执行完该宏任务下所有同步任务后，即调用栈清空后，该宏任务被推出宏任务队列，然后微任务队列开始按照入队顺序，依次执行其中的微任务，直至微任务队列清空为止；
3. 当微任务队列清空后，一个事件循环结束；
4. 接着从宏任务队列中，找到下一个执行的宏任务，开始第二个事件循环，直至宏任务队列清空为止。

#### 页面渲染
&emsp;&emsp;每次当一次事件循环结束后，即一个宏任务执行完成后以及微任务队列被清空后，浏览器就会进行一次页面更新渲染。

### 2. 讲一讲this
1. this是在执行上下文创建时确定的一个在执行过程中不可更改的变量。
2. 当函数独立调用的时候，在严格模式下它的this指向undefined，在非严格模式下，当this指向undefined的时候，自动指向全局对象(浏览器中就是window)
3. 作为对象的一个方法调用，这时候this指向调用它的对象。
4. 如果函数作为构造函数用，那么其中的this就代表它即将new出来的对象。
5. 箭头函数会捕获其所在上下文的 this 值，作为自己的 this 值


### 3. Promise
#### 什么是Promise
&emsp;&emsp;Promise是异步编程的一种解决方案
#### 执行器函数是立即调用的吗？then是立即调用的吗？
&emsp;&emsp;Promise构造函数是同步执行的，then方法是异步执行的
#### await之前和之后的代码是同步还是异步的？
&emsp;&emsp;await之前是同步调用，await之后是异步调用

### 4. es6的class和super都是干什么用的

### 5. 防抖与节流
* 防抖：触发高频事件后n秒内函数只会执行一次，如果n秒内高频事件再次被触发，则重新计算时间。
* 节流：高频事件触发，但在n秒内只会执行一次，所以节流会稀释函数的执行频率。

### 6. 纯函数
1. 它应始终返回相同的值。不管调用该函数多少次，无论今天、明天还是将来某个时候调用它。 
2. 自包含（不使用全局变量）。 
3. 它不应修改程序的状态或引起副作用（修改全局变量）。

### 7. 深拷贝与浅拷贝
* 浅拷贝：一般指的是把对象的第一层拷贝到一个新对象上去
* 深拷贝：一般需要借助递归实现，如果对象的值还是个对象，要进一步地深入拷贝，完全替换掉每一个复杂类型的引用。
